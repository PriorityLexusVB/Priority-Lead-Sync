const { XMLParser } = require("fast-xml-parser");

// Parse an entire email body and return the root ADF object.
// The parser is tolerant of extra text before or after the XML
// and does not require manual slicing of the message.
function parseAdfEmail(bodyText = "") {
  try {
    const parser = new XMLParser({ ignoreAttributes: false });
    const json = parser.parse(bodyText);

    if (!json?.adf) {
      return null;
    }

    return json.adf;
  } catch (err) {
    return null;
  }
}

// Utility to extract lead information from an ADF contact object
// Expected contact format generated by an XML parser using
// attrkey: "@_" and charkey: "#text". For example:
// {
//   name: [
//     { '@_part': 'first', '#text': 'John' },
//     { '@_part': 'last', '#text': 'Doe' }
//   ],
//   phone: { '#text': '555-1234' },
//   email: { '#text': 'john@example.com' }
// }

function extractLeadFromContact(contact = {}) {
  // Ensure name is always treated as an array
  const nameEntries = [];
  if (contact.name) {
    if (Array.isArray(contact.name)) {
      nameEntries.push(...contact.name);
    } else {
      nameEntries.push(contact.name);
    }
  }

  // Find the first and last name objects based on the `@_part` attribute
  const firstObj = nameEntries.find((n) => n?.["@_part"] === "first");
  const lastObj = nameEntries.find((n) => n?.["@_part"] === "last");

  const firstName = firstObj?.["#text"] || "";
  const lastName = lastObj?.["#text"] || "";

  // Extract phone and email text content
  const phoneObj = Array.isArray(contact.phone) ? contact.phone[0] : contact.phone;
  const emailObj = Array.isArray(contact.email) ? contact.email[0] : contact.email;

  const phone = phoneObj?.["#text"] || "";
  const email = emailObj?.["#text"] || "";

  return {
    firstName,
    lastName,
    phone,
    email,
  };
}

module.exports = {
  parseAdfEmail,
  extractLeadFromContact,
};
