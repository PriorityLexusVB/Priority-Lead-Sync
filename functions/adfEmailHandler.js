const { XMLParser } = require("fast-xml-parser");

// Parse an entire email body and return the root ADF object.
// The parser is tolerant of extra text before or after the XML
// and does not require manual slicing of the message.
//
// Example email body structure:
//   Some intro text...
//   <adf version="1.0">
//     <prospect>
//       <customer>
//         <contact>
//           <name part="first">Jane</name>
//           <name part="last">Doe</name>
//           <email>jane@example.com</email>
//         </contact>
//       </customer>
//     </prospect>
//   </adf>
//   Some footer text...
function parseAdfEmail(bodyText = "") {
  try {
    const parser = new XMLParser({ ignoreAttributes: false });
    const json = parser.parse(bodyText);

    if (!json?.adf) {
      console.error("❌ Parsing error: json.adf not found.");
      return null;
    }

    return json.adf;
  } catch (err) {
    console.error("❌ Failed to parse ADF email:", err);
    return null;
  }
}

// Utility to extract lead information from an ADF contact object
// Expected contact format generated by an XML parser using
// attrkey: "@_" and charkey: "#text". For example:
// {
//   name: [
//     { '@_part': 'first', '#text': 'John' },
//     { '@_part': 'last', '#text': 'Doe' }
//   ],
//   phone: { '#text': '555-1234' },
//   email: { '#text': 'john@example.com' }
// }

function extractLeadFromContact(contact = {}) {
  // Helper to normalize fast-xml-parser output into a text value
  const getText = (value) => {
    if (Array.isArray(value)) {
      value = value[0];
    }
    if (value && typeof value === "object") {
      const text = value["#text"];
      return typeof text === "string" && text.trim() ? text : "Missing";
    }
    if (typeof value === "string") {
      return value.trim() || "Missing";
    }
    return "Missing";
  };

  // Ensure name is always treated as an array
  const nameEntries = Array.isArray(contact.name)
    ? contact.name
    : contact.name
    ? [contact.name]
    : [];

  // Find the first and last name objects based on the `@_part` attribute
  const firstObj = nameEntries.find((n) => n?.["@_part"] === "first");
  const lastObj = nameEntries.find((n) => n?.["@_part"] === "last");

  const first_name = getText(firstObj);
  const last_name = getText(lastObj);

  // Extract phone and email text content, falling back to string values
  const phone = getText(contact.phone);
  const email = getText(contact.email);

  return {
    first_name,
    last_name,
    phone,
    email,
  };
}

module.exports = {
  parseAdfEmail,
  extractLeadFromContact,
};
